# Swirl lectures Johns Hopkins

################################################################################################################################################################################################################################

## GETTING AND CLEANING DATA 
## Lecture 1 in Swirl 

#####################################################################################################################################################################################################################

#GETTING AND CLEANING DATA LESSON 4 SWIRL

#| Let's build a chain of dplyr commands one step
#| at a time, starting with the script I just
#| opened for you.

# select() the following columns from cran. Keep in mind
# that when you're using the chaining operator, you don't
# need to specify the name of the data tbl in your call to
# select().
#
# 1. ip_id
# 2. country
# 3. package
# 4. size
#
# The call to print() at the end of the chain is optional,
# but necessary if you want your results printed to the
# console. Note that since there are no additional arguments
# to print(), you can leave off the parentheses after
# the function name. This is a convenient feature of the %>%
# operator.

cran %>%
  select(ip_id, country, package, size) %>%
	print

#Source: local data frame [225,468 x 4]

#   ip_id country      package    size
#1      1      US    htmltools   80589
#2      2      US      tseries  321767
#3      3      US        party  748063
#4      3      US        Hmisc  606104
#5      4      CA       digest   79825
#6      3      US randomForest   77681
#7      3      US         plyr  393754
#8      5      US      whisker   28216
#9      6      CN         Rcpp    5928
#10     7      US     hflights 2206029
#..   ...     ...          ...     ...

# Use mutate() to add a column called size_mb that contains
# the size of each download in megabytes (i.e. size / 2^20).
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %>%
  select(ip_id, country, package, size) %>%
  mutate(size_mb=size/2^20) %>%
  print

#   ip_id country      package    size     size_mb
#1      1      US    htmltools   80589 0.076855659
#2      2      US      tseries  321767 0.306860924
#3      3      US        party  748063 0.713408470
#4      3      US        Hmisc  606104 0.578025818
#5      4      CA       digest   79825 0.076127052
#6      3      US randomForest   77681 0.074082375
#7      3      US         plyr  393754 0.375513077
#8      5      US      whisker   28216 0.026908875
#9      6      CN         Rcpp    5928 0.005653381
#10     7      US     hflights 2206029 2.103833199
#..   ...     ...          ...     ...         ...

# Use filter() to select all rows for which size_mb is
# less than or equal to (<=) 0.5.
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %>%
  select(ip_id, country, package, size) %>%
  mutate(size_mb = size / 2^20) %>%
  filter(size_mb <= 0.5) %>%
  print 

#   ip_id country      package   size     size_mb
#1      1      US    htmltools  80589 0.076855659
#2      2      US      tseries 321767 0.306860924
#3      4      CA       digest  79825 0.076127052
#4      3      US randomForest  77681 0.074082375
#5      3      US         plyr 393754 0.375513077
#6      5      US      whisker  28216 0.026908875
#7      6      CN         Rcpp   5928 0.005653381
#8     13      DE        ipred 186685 0.178036690
#9     14      US       mnormt  36204 0.034526825
#10    16      US    iterators 289972 0.276538849
#..   ...     ...          ...    ...         ...

# arrange() the result by size_mb, in descending order.
#
# If you want your results printed to the console, add
# print to the end of your chain.

cran %>%
  select(ip_id, country, package, size) %>%
  mutate(size_mb = size / 2^20) %>%
  filter(size_mb <= 0.5) %>%
  arrange(desc(size_mb)) %>%
  print 

#   ip_id country               package   size
#1  11034      DE                  phia 524232
#2   9643      US                   tis 524152
#3   1542      IN               RcppSMC 524060
#4  12354      US                 lessR 523916
#5  12072      US            colorspace 523880
#6   2514      KR              depmixS4 523863
#7   1111      US              depmixS4 523858
#8   8865      CR              depmixS4 523858
#9   5908      CN RcmdrPlugin.KMggplot2 523852
#10 12354      US RcmdrPlugin.KMggplot2 523852
#..   ...     ...                   ...    ...
#Variables not shown: size_mb (dbl)

#| Keep up the great work!

  #|==================================================================================================| 100%

#| In this lesson, you learned about grouping and
#| chaining using dplyr. You combined some of the
#| things you learned in the previous lesson with
#| these more advanced ideas to produce concise,
#| readable, and highly effective code. Welcome to
#| the wonderful world of dplyr!
  


## Getting and cleaning data, lecture 3 tidying data 

install.packages("dplyr")
library(dplyr)

cran %>% 
    select(ip_id, country, package, size)
    print
    
#versus 
select(cran, ip_id, country, package, size)

#tidying data with tidyr package 

install.packages("tidyr")
install.packages("stringi")
library(stringi)
library(tidyr)

#In this lesson, you'll learn how to tidy your data with the tidyr package.

#Tidy data is standard format. 
#tidy data satisfies 3 conditions
    #each variable forms a column
    #each obs forms a row
    #each type of obs unit forms a table 

#use the gather() function from tidyr to have one column for each of the variables 

gather(students, sex, count, -grade) #gets all columns except grade
#combined the variables for A-Male and A-Female, etc ...
    
#now lets see multiple variables stored in one column 

res<-gather(students2, sex_class, count, -grade)
#print res to see it's change
res

#still there are two diff variables (sex and class) stored together in teh sex_class column. tidyr can provide convenient separate() function to separate one column in to multiple. 

?separate
separate(res,sex_class,into=c("sex","class")) #we didn't use the sep argument, which is sometimes necessary to tell R how to separate the column 
#it splits on non alphanumeric values. 


# Repeat your calls to gather() and separate(), but this time
# use the %>% operator to chain the commands together without
# storing an intermediate result.
#
# If this is your first time seeing the %>% operator, check
# out ?chain, which will bring up the relevant documentation.
# You can also look at the Examples section at the bottom
# of ?gather and ?separate.
#
# The main idea is that the result to the left of %>%
# takes the place of the first argument of the function to
# the right. Therefore, you OMIT THE FIRST ARGUMENT to each
# function.
#
students2 %>%
  gather(sex_class, count, -grade) %>%
  separate(sex_class, c("sex","class")) %>%
  print

  
#sometimes variables are stored as rows and columns
#    name    test class1 class2 class3 class4 class5
#1  Sally midterm      A   <NA>      B   <NA>   <NA>
#2  Sally   final      C   <NA>      C   <NA>   <NA>
#3   Jeff midterm   <NA>      D   <NA>      A   <NA>
#4   Jeff   final   <NA>      E   <NA>      C   <NA>
#5  Roger midterm   <NA>      C   <NA>   <NA>      B
#6  Roger   final   <NA>      A   <NA>   <NA>      A
#7  Karen midterm   <NA>   <NA>      C      A   <NA>
#8  Karen   final   <NA>   <NA>      C      A   <NA>
#9  Brian midterm      B   <NA>   <NA>   <NA>      A
#10 Brian   final      B   <NA>   <NA>   <NA>      C

#| In students3, we have midterm and final exam grades for five
#| students, each of whom were enrolled in exactly two of five
#| possible classes.

#| The first variable, name, is already a column and should
#| remain as it is. The headers of the last five columns,
#| class1 through class5, are all different values of what
#| should be a class variable. The values in the test column,
#| midterm and final, should each be its own variable
#| containing the respective grades for each student.

#| This will require multiple steps, which we will build up
#| gradually using %>%. Edit the R script, save it, then type
#| submit() when you are ready. Type reset() to reset the
#| script to its original state.

#script begin:
# Call gather() to gather the columns class1 through
# through class5 into a new variable called class.
# The 'key' should be class, and the 'value'
# should be grade.
#
# tidyr makes it easy to reference multiple adjacent
# columns with class1:class5, just like with sequences
# of numbers.
#
# Since each student is only enrolled in two of
# the five possible classes, there are lots of missing
# values (i.e. NAs). Use the argument na.rm = TRUE
# to omit these values from the final result.
#
# Remember that when you're using the %>% operator,
# the value to the left of it gets inserted as the
# first argument to the function on the right.
#
# Consult ?gather and/or ?chain if you get stuck.
#
students3 %>%
  gather(class,grade,class1:class5 ,na.rm = TRUE) %>%
  print
#recall gather(data, key, value, ..., na.rm = FALSE, convert = FALSE)


#next part will require spread()
?spread


#sometimes variables are stored as rows and columns
#    name    test class1 class2 class3 class4 class5
#1  Sally midterm      A   <NA>      B   <NA>   <NA>
#2  Sally   final      C   <NA>      C   <NA>   <NA>
#3   Jeff midterm   <NA>      D   <NA>      A   <NA>
#4   Jeff   final   <NA>      E   <NA>      C   <NA>
#5  Roger midterm   <NA>      C   <NA>   <NA>      B
#6  Roger   final   <NA>      A   <NA>   <NA>      A
#7  Karen midterm   <NA>   <NA>      C      A   <NA>
#8  Karen   final   <NA>   <NA>      C      A   <NA>
#9  Brian midterm      B   <NA>   <NA>   <NA>      A
#10 Brian   final      B   <NA>   <NA>   <NA>      C

#turns into...

#    name    test  class grade
#1  Sally midterm class1     A
#2  Sally   final class1     C
#3  Brian midterm class1     B
#4  Brian   final class1     B
#5   Jeff midterm class2     D
#6   Jeff   final class2     E
#7  Roger midterm class2     C
#8  Roger   final class2     A
#9  Sally midterm class3     B
#10 Sally   final class3     C
#11 Karen midterm class3     C
#12 Karen   final class3     C
#13  Jeff midterm class4     A
#14  Jeff   final class4     C
#15 Karen midterm class4     A
#16 Karen   final class4     A
#17 Roger midterm class5     B
#18 Roger   final class5     A
#19 Brian midterm class5     A
#20 Brian   final class5     C

#script start:
# This script builds on the previous one by appending
# a call to spread(), which will allow us to turn the
# values of the test column, midterm and final, into
# column headers (i.e. variables).
#
# You only need to specify two arguments to spread().
# Can you figure out what they are? (Hint: You don't
# have to specify the data argument since we're using
# the %>% operator.
#
students3 %>%
  gather(class, grade, class1:class5, na.rm = TRUE) %>%
  spread(test, grade) %>%
  print
#spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE)

#produces ...

#    name  class final midterm
#1  Brian class1     B       B
#2  Brian class5     C       A
#3   Jeff class2     E       D
#4   Jeff class4     C       A
#5  Karen class3     C       C
#6  Karen class4     A       A
#7  Roger class2     A       C
#8  Roger class5     A       B
#9  Sally class1     C       A
#10 Sally class3     C       B

#we want the classes to be numeric (eg class 1 = 1) 
#this requires extract_numeric()

?extract_numeric
extract_numeric("class5") #returns 5

# We want the values in the class columns to be
# 1, 2, ..., 5 and not class1, class2, ..., class5.
#
# Use the mutate() function from dplyr along with
# extract_numeric(). Hint: You can "overwrite" a column
# with mutate() by assigning a new value to the existing
# column instead of creating a new column.
#
# Check out ?mutate and/or ?extract_numeric if you need
# a refresher.
#
#REMEMBER THIS IS WHAT WE ARE OPERATING ON 

#    name  class final midterm
#1  Brian class1     B       B
#2  Brian class5     C       A
#3   Jeff class2     E       D
#4   Jeff class4     C       A
#5  Karen class3     C       C
#6  Karen class4     A       A
#7  Roger class2     A       C
#8  Roger class5     A       B
#9  Sally class1     C       A
#10 Sally class3     C       B
students3 %>%
  gather(class, grade, class1:class5, na.rm = TRUE) %>%
  spread(test, grade) %>%
  mutate(class=extract_numeric(class)) %>%
  print
#returns...
#    name class final midterm
#1  Brian     1     B       B
#2  Brian     5     C       A
#3   Jeff     2     E       D
#4   Jeff     4     C       A
#5  Karen     3     C       C
#6  Karen     4     A       A
#7  Roger     2     A       C
#8  Roger     5     A       B
#9  Sally     1     C       A
#10 Sally     3     C       B

#| The fourth messy data problem we'll look at occurs when
#| multiple observational units are stored in the same table.
#| students4 presents an example of this. Take a look at the
#| data now.

#    id  name sex class midterm final
#1  168 Brian   F     1       B     B
#2  168 Brian   F     5       A     C
#3  588 Sally   M     1       A     C
#4  588 Sally   M     3       B     C
#5  710  Jeff   M     2       D     E
#6  710  Jeff   M     4       A     C
#7  731 Roger   F     2       C     A
#8  731 Roger   F     5       B     A
#9  908 Karen   M     3       C     C
#10 908 Karen   M     4       A     A

#| students4 is almost the same as our tidy version of
#| students3. The only difference is that students4 provides a
#| unique id for each student, as well as his or her sex (M =
#| male; F = female).

#| At first glance, there doesn't seem to be much of a problem
#| with students4. All columns are variables and all rows are
#| observations. However, notice that each id, name, and sex is
#| repeated twice, which seems quite redundant. This is a hint
#| that our data contains multiple observational units in a
#| single table.

#| Our solution will be to break students4 into two separate
#| tables -- one containing basic student information (id,
#| name, and sex) and the other containing grades (id, class,
#| midterm, final).
#| 
#| Edit the R script, save it, then type submit() when you are
#| ready. Type reset() to reset the script to its original
#| state.

#begin script:

# Complete the chained command below so that we are
# selecting the id, name, and sex column from students4
# and storing the result in student_info.
#
student_info <- students4 %>%
  select(id,name,sex) %>%
  print
#returns...

#    id  name sex
#1  168 Brian   F
#2  168 Brian   F
#3  588 Sally   M
#4  588 Sally   M
#5  710  Jeff   M
#6  710  Jeff   M
#7  731 Roger   F
#8  731 Roger   F
#9  908 Karen   M
#10 908 Karen   M

#| Notice anything strange about student_info? It contains five
#| duplicate rows! See the script for directions on how to fix
#| this. Save the script and type submit() when you are ready,
#| or type reset() to reset the script to its original state.


  
#| Notice anything strange about student_info? It contains five
#| duplicate rows! See the script for directions on how to fix
#| this. Save the script and type submit() when you are ready,
#| or type reset() to reset the script to its original state.

student_info #note five duplicate rows, not unique observations

#    id  name sex
#1  168 Brian   F
#2  168 Brian   F
#3  588 Sally   M
#4  588 Sally   M
#5  710  Jeff   M
#6  710  Jeff   M
#7  731 Roger   F
#8  731 Roger   F
#9  908 Karen   M
#10 908 Karen   M

#start script:

# Add a call to unique() below, which will remove
# duplicate rows from student_info.
#
# Like with the call to the print() function below,
# you can omit the parentheses after the function name.
# This is a nice feature of %>% that applies when
# there are no additional arguments to specify.
#
student_info <- students4 %>%
  select(id, name, sex) %>%
  unique %>%
  print

#returns
#   id  name sex
#1 168 Brian   F
#3 588 Sally   M
#5 710  Jeff   M
#7 731 Roger   F
#9 908 Karen   M

#| Now, using the script I just opened for you, create a second
#| table called gradebook using the id, class, midterm, and
#| final columns (in that order).
#| 
#| Edit the R script, save it, then type submit() when you are
#| ready. Type reset() to reset the script to its original
#| state.

# select() the id, class, midterm, and final columns
# (in that order) and store the result in gradebook.
#
gradebook <- students4 %>%
  select(id, class, midterm, final) %>%
  print

#returns
#    id class midterm final
#1  168     1       B     B
#2  168     5       A     C
#3  588     1       A     C
#4  588     3       B     C
#5  710     2       D     E
#6  710     4       A     C
#7  731     2       C     A
#8  731     5       B     A
#9  908     3       C     C
#10 908     4       A     A

#| It's important to note that we left the id column in both
#| tables. In the world of relational databases, 'id' is called
#| our 'primary key' since it allows us to connect each student
#| listed in student_info with their grades listed in
#| gradebook. Without a unique identifier, we might not know
#| how the tables are related. (In this case, we could have
#| also used the name variable, since each student happens to
#| have a unique name.)



#| The fifth and final messy data scenario that we'll address
#| is when a single observational unit is stored in multiple
#| tables. It's the opposite of the fourth problem.

#| To illustrate this, we've created two datasets, passed and
#| failed. Take a look at passed now.
#passed
#   name class final
#1 Brian     1     B
#2 Roger     2     A
#3 Roger     5     A
#4 Karen     4     A
#failed
#   name class final
#1 Brian     5     C
#2 Sally     1     C
#3 Sally     3     C
#4  Jeff     2     E
#5  Jeff     4     C
#6 Karen     3     C

#| The name of each dataset actually represents the value of a
#| new variable that we will call 'status'. Before joining the
#| two tables together, we'll add a new column to each
#| containing this information so that its not lost when we put
#| everything together.

#| Use dplyr's mutate() to add a new column to the passed
#| table. The column should be called status and the value,
#| "passed" (a character string), should be the same for all
#| students. 'Overwrite' the current version of passed with the
#| new one.

passed <- passed %>%
    mutate("status" = "passed")

failed <- failed %>%
    mutate("status" = "failed")

#| Now, pass as arguments the passed and failed tables (in
#| order) to the dplyr function bind_rows(), which will join
#| them together into a single unit. Check ?bind_rows if you
#| need help.
#| 
#| Note: bind_rows() is only available in dplyr 0.4.0 or later.
#| If you have an older version of dplyr, please quit the
#| lesson, update dplyr, then restart the lesson where you left
#| off. If you're not sure what version of dplyr you have, type
#| packageVersion('dplyr').


bind_rows(passed, failed)

#    name class final status
#1  Brian     1     B passed
#2  Roger     2     A passed
#3  Roger     5     A passed
#4  Karen     4     A passed
#5  Brian     5     C failed
#6  Sally     1     C failed
#7  Sally     3     C failed
#8   Jeff     2     E failed
#9   Jeff     4     C failed
#10 Karen     3     C failed

#| Of course, we could arrange the rows however we wish at this
#| point, but the important thing is that each row is an
#| observation, each column is a variable, and the table
#| contains a single observational unit. Thus, the data are
#| tidy.

#PUTTING IT TOGETHER

#| The SAT is a popular college-readiness exam in the United
#| States that consists of three sections: critical reading,
#| mathematics, and writing. Students can earn up to 800 points
#| on each section. This dataset presents the total number of
#| students, for each combination of exam section and sex,
#| within each of six score ranges. It comes from the 'Total
#| Group Report 2013', which can be found here:
#| 
#| http://research.collegeboard.org/programs/sat/data/cb-seniors-2013

sat 

#  score_range read_male read_fem read_total math_male math_fem
#1     700-800     40151    38898      79049     74461    46040
#2     600-690    121950   126084     248034    162564   133954
#3     500-590    227141   259553     486694    233141   257678
#4     400-490    242554   296793     539347    204670   288696
#5     300-390    113568   133473     247041     82468   131025
#6     200-290     30728    29154      59882     18788    26562
#Variables not shown: math_total (int), write_male (int),
#  write_fem (int), write_total (int)

#| As we've done before, we'll build up a series of chained
#| commands, using functions from both tidyr and dplyr. Edit
#| the R script, save it, then type submit() when you are
#| ready. Type reset() to reset the script to its original
#| state.

# Accomplish the following three goals:
#
# 1. select() all columns that do NOT contain the word "total",
# since if we have the male and female data, we can always
# recreate the total count in a separate column, if we want it.
# Hint: Use the contains() function, which you'll
# find detailed in 'Selection' section of ?select.
#
# 2. gather() all columns EXCEPT score_range, using
# key = part_sex and value = count.
#
# 3. separate() part_sex into two separate variables (columns),
# called "part" and "sex", respectively. You may need to check
# the 'Examples' section of ?separate to remember how the 'into'
# argument should be phrased.
#
sat %>% 
    select(-contains("total")) %>%
    gather(part_sex, count, -c(score_range)) %>%
    separate(part_sex,into = c("part","sex")) %>% 
    print

#separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
#  convert = FALSE, extra = "error", ...)

#   score_range part  sex  count
#1      700-800 read male  40151
#2      600-690 read male 121950
#3      500-590 read male 227141
#4      400-490 read male 242554
#5      300-390 read male 113568
#6      200-290 read male  30728
#7      700-800 read  fem  38898
#8      600-690 read  fem 126084
#9      500-590 read  fem 259553
#10     400-490 read  fem 296793
#..         ...  ...  ...    ...

#| Finish off the job by following the directions in the
#| script. Save the script and type submit() when you are
#| ready, or type reset() to reset the script to its original
#| state.



# Append two more function calls to accomplish the following:
#
# 1. Use group_by() (from dplyr) to group the data by part and
# sex, in that order.
#
# 2. Use mutate to add two new columns, whose values will be
# automatically computed group-by-group:
#
#   * total = sum(count)
#   * prop = count / total
#
sat %>%
  select(-contains("total")) %>%
  gather(part_sex, count, -score_range) %>%
  separate(part_sex, c("part", "sex")) %>%
  group_by(part, sex) %>%
  mutate(total = sum(count),
         prop = count / total 
  ) %>% print

#group_by(.data, ..., add = FALSE)

#returns  

#   score_range part  sex  count  total       prop
#1      700-800 read male  40151 776092 0.05173485
#2      600-690 read male 121950 776092 0.15713343
#3      500-590 read male 227141 776092 0.29267278
#4      400-490 read male 242554 776092 0.31253253
#5      300-390 read male 113568 776092 0.14633317
#6      200-290 read male  30728 776092 0.03959324
#7      700-800 read  fem  38898 883955 0.04400450
#8      600-690 read  fem 126084 883955 0.14263622
#9      500-590 read  fem 259553 883955 0.29362694
#10     400-490 read  fem 296793 883955 0.33575578
#..         ...  ...  ...    ...    ...        ...





#####################################################################################################################################################################################################################

#GETTING AND CLEANING DATA LESSON 4 SWIRL

install.packages("lubridate")
library(lubridate)

#| In this lesson, we'll explore the lubridate R
#| package, by Garrett Grolemund and Hadley
#| Wickham. According to the package authors,
#| "lubridate has a consistent, memorable syntax,
#| that makes working with dates fun instead of
#| frustrating." If you've ever worked with dates
#| in R, that statement probably has your
#| attention.

#| Unfortunately, due to different date and time
#| representations, this lesson is only guaranteed
#| to work with an "en_US.UTF-8" locale. To view
#| your locale, type Sys.getlocale("LC_TIME").

Sys.getlocale("LC_TIME")
#[1] "English_United States.1252"
#| If the output above is not "en_US.UTF-8", this
#| lesson is not guaranteed to work correctly

#| lubridate was automatically installed (if
#| necessary) and loaded upon starting this
#| lesson. To build the habit, we'll go ahead and
#| (re)load the package now. Type
#| library(lubridate) to do so.

library(lubridate)

this_day <- today()
#[1] "2015-04-16"

#| There are three components to this date. In
#| order, they are year, month, and day. We can
#| extract any of these components using the
#| year(), month(), or day() function,
#| respectively. Try any of those on this_day now.

year(this_day)
month(this_day)
day(this_day)

#| We can also get the day of the week from
#| this_day using the wday() function. It will be
#| represented as a number, such that 1 = Sunday,
#| 2 = Monday, 3 = Tuesday, etc. Give it a shot.

wday(this_day)
#[1] 5
#1=sun, 3=tues, 5=thurs, 7=sat 

#| Now try the same thing again, except this time
#| add a second argument, label = TRUE, to display
#| the *name* of the weekday (represented as an
#| ordered factor).

wday(this_day,label=TRUE)

#| In addition to handling dates, lubridate is
#| great for working with date and time
#| combinations, referred to as date-times. The
#| now() function returns the date-time
#| representing this exact moment in time. Give it
#| a try and store the result in a variable called
#| this_moment.

this_moment<-now()
this_moment 

#[1] "2015-04-16 13:51:47 CDT"

#| Just like with dates, we can extract the year,
#| month, day, or day of week. However, we can
#| also use hour(), minute(), and second() to
#| extract specific time information. Try any of
#| these three new functions now to extract one
#| piece of time information from this_moment.

hour(this_moment)
minute(this_moment)
second(this_moment)

#| To see how these functions work, try
#| ymd("1989-05-17"). You must surround the date
#| with quotes. Store the result in a variable
#| called my_date.

my_date<-ymd("1986-12-26")
my_date
#[1] "1986-12-26 UTC"

#| It looks almost the same, except for the
#| addition of a time zone, which we'll discuss
#| later in the lesson. Below the surface, there's
#| another important change that takes place when
#| lubridate parses a date. Type class(my_date) to
#| see what that is.

class(my_date)
#[1] "POSIXct" "POSIXt" 

#| So ymd() took a character string as input and
#| returned an object of class POSIXct. It's not
#| necessary that you understand what POSIXct is,
#| but just know that it is one way that R stores
#| date-time information internally.

#| "1989-05-17" is a fairly standard format, but
#| lubridate is 'smart' enough to figure out many
#| different date-time formats. Use ymd() to parse
#| "1989 May 17". Don't forget to put quotes
#| around the date!


ymd("1989 May 17")
#[1] "1989-05-17 UTC"

#| Despite being formatted differently, the last
#| two dates had the year first, then the month,
#| then the day. Hence, we used ymd() to parse
#| them. What do you think the appropriate
#| function is for parsing "March 12, 1975"? Give
#| it a try.

mdy("March 12, 1975")
#[1] "1975-03-12 UTC"

dmy(25081985)
#[1] "1985-08-25 UTC"

#| But be careful, it's not magic. Try
#| ymd("192012") to see what happens when we give
#| it something more ambiguous. Surround the
#| number with quotes again, just to be consistent
#| with the way most dates are represented (as
#| character strings).

#| You got a warning message because it was
#| unclear what date you wanted. When in doubt,
#| it's best to be more explicit. Repeat the same
#| command, but add two dashes OR two forward
#| slashes to "192012" so that it's clear we want
#| January 2, 1920.

ymd("1920-1-2")
#[1] "1920-01-02 UTC"

#| In addition to dates, we can parse date-times.
#| I've created a date-time object called dt1.
#| Take a look at it now.

dt1
#[1] "2014-08-23 17:23:02"

ymd_hms(dt1)
#[1] "2014-08-23 17:23:02 UTC"

#| What if we have a time, but no date? Use the
#| appropriate lubridate function to parse
#| "03:22:14" (hh:mm:ss).

hms("03:22:14")

#| lubridate is also capable of handling vectors
#| of dates, which is particularly helpful when
#| you need to parse an entire column of data.
#| I've created a vector of dates called dt2. View
#| its contents now.

dt2
#[1] "2014-05-14" "2014-09-22" "2014-07-11"

ymd(dt2)

#| The update() function allows us to update one
#| or more components of a date-time. For example,
#| let's say the current time is 08:34:55
#| (hh:mm:ss). Update this_moment to the new time
#| using the following command:
#| 
#| update(this_moment, hours = 8, minutes = 34,
#| seconds = 55).

this_moment
update(this_moment,hours=8,minutes=34,seconds=55)
[1] "2015-04-16 08:34:55 CDT"

#| It's important to recognize that the previous
#| command does not alter this_moment unless we
#| reassign the result to this_moment. To see
#| this, print the contents of this_moment.

this_moment
#[1] "2015-04-16 13:51:47 CDT"

#| Unless you're a superhero, some time has passed
#| since you first created this_moment. Use
#| update() to make it match the current time,
#| specifying at least hours and minutes. Assign
#| the result to this_moment, so that this_moment
#| will contain the new time.

this_moment<-update(this_moment,hours=2,minutes=17)
this_moment 
#[1] "2015-04-16 02:17:47 CDT"

#| Now, pretend you are in New York City and you
#| are planning to visit a friend in Hong Kong.
#| You seem to have misplaced your itinerary, but
#| you know that your flight departs New York at
#| 17:34 (5:34pm) the day after tomorrow. You also
#| know that your flight is scheduled to arrive in
#| Hong Kong exactly 15 hours and 50 minutes after
#| departure.

#| Let's reconstruct your itinerary from what you
#| can remember, starting with the full date and
#| time of your departure. We will approach this
#| by finding the current date in New York, adding
#| 2 full days, then setting the time to 17:34.

#| To find the current date in New York, we'll use
#| the now() function again. This time, however,
#| we'll specify the time zone that we want:
#| "America/New_York". Store the result in a
#| variable called nyc. Check out ?now if you need
#| help.

nyc<-now("America/New_York")

#| For a complete list of valid time zones for use
#| with lubridate, check out the following
#| Wikipedia page:
#| 
#| http://en.wikipedia.org/wiki/List_of_tz_database_time_zones

nyc
#[1] "2015-04-16 15:20:22 EDT"

#| Your flight is the day after tomorrow (in New
#| York time), so we want to add two days to nyc.
#| One nice aspect of lubridate is that it allows
#| you to use arithmetic operators on dates and
#| times. In this case, we'd like to add two days
#| to nyc, so we can use the following expression:
#| nyc + days(2). Give it a try, storing the
#| result in a variable called depart.

depart<-nyc+days(2)
depart
#[1] "2015-04-18 15:20:22 EDT"

#| So now depart contains the date of the day
#| after tomorrow. Use update() to add the correct
#| hours (17) and minutes (34) to depart. Reassign
#| the result to depart.

depart<-update(depart,hours=17,minutes=34)
depart
#[1] "2015-04-18 17:34:22 EDT"

#| Your friend wants to know what time she should
#| pick you up from the airport in Hong Kong. Now
#| that we have the exact date and time of your
#| departure from New York, we can figure out the
#| exact time of your arrival in Hong Kong.

arrive<-depart+hours(15)+minutes(50)

#| The arrive variable contains the time that it
#| will be in New York when you arrive in Hong
#| Kong. What we really want to know is what time
#| is will be in Hong Kong when you arrive, so
#| that your friend knows when to meet you.

#| The with_tz() function returns a date-time as
#| it would appear in another time zone. Use
#| ?with_tz to check out the documentation.

?with_tz
#with_tz(time, tzone = "")

#| Use with_tz() to convert arrive to the
#| "Asia/Hong_Kong" time zone. Reassign the result
#| to arrive, so that it will get the new value.

arrive<-with_tz(arrive,"Asia/Hong_Kong")

arrive 
#[1] "2015-04-19 21:24:22 HKT"

#| Fast forward to your arrival in Hong Kong. You
#| and your friend have just met at the airport
#| and you realize that the last time you were
#| together was in Singapore on June 17, 2008.
#| Naturally, you'd like to know exactly how long
#| it has been.

#| Use the appropriate lubridate function to parse
#| "June 17, 2008", just like you did near the
#| beginning of this lesson. This time, however,
#| you should specify an extra argument, tz =
#| "Singapore". Store the result in a variable
#| called last_time.

last_time<-mdy("June 17, 2008",tz="Singapore")
last_time
#[1] "2008-06-17 SGT"

?new_interval
#new_interval(start, end, tzone = attr(start, "tzone"))

#| Create a new_interval() that spans from
#| last_time to arrive. Store it in a new variable
#| called how_long

how_long<-new_interval(last_time,arrive)

#| Now use as.period(how_long) to see how long
#| it's been.

as.period(how_long)
#[1] "6y 10m 2d 21H 24M 22.2164700031281S"

#| This is where things get a little tricky.
#| Because of things like leap years, leap
#| seconds, and daylight savings time, the length
#| of any given minute, day, month, week, or year
#| is relative to when it occurs. In contrast, the
#| length of a second is always the same,
#| regardless of when it occurs.

#| To address these complexities, the authors of
#| lubridate introduce four classes of time
#| related objects: instants, intervals,
#| durations, and periods. These topics are beyond
#| the scope of this lesson, but you can find a
#| complete discussion in the 2011 Journal of
#| Statistical Software paper titled 'Dates and
#| Times Made Easy with lubridate'.

#| This concludes our introduction to working with
#| dates and times in lubridate. I created a
#| little timer that started running in the
#| background when you began this lesson. Type
#| stopwatch() to see how long you've been
#| working!

stopwatch() #shows how long i've been working 
#[1] "51M 42.3517091274261S"








####

## Exploratory Data Analysis Swirl Lecture 1 
# Principles of Analytic Graphs 

library(ggplot2)

install.packages("jpeg")
library(jpeg)

#| In this lesson, we'll discuss some basic
#| principles of presenting data effectively.
#| These will illustrate some fundamental concepts
#| of displaying results in order to make them
#| more meaningful and convincing. These
#| principles are cribbed from Edward Tufte's
#| great 2006 book, Beautiful Evidence. You can
#| read more about them at the www.edwardtufte.com
#| website.

#| As a warm-up, which of the following would NOT
#| be a good use of analytic graphing?

#1: To decide which horse to bet on at the track
#2: To show causality, mechanism, explanation
#3: To show comparisons
#4: To show multivariate data

#1 

#| You're ready to start. Graphs give us a visual
#| form of data, and the first principle of
#| analytic graphs is to show some comparison.
#| You'll hear more about this when you study
#| statistical inference (another great course
#| BTW), but evidence for a hypothesis is always
#| relative to another competing or alternative
#| hypothesis.

#| When presented with a claim that something is
#| good, you should always ask "Compared to What?"
#| This is why in commercials you often hear the
#| phrase "other leading brands". An implicit
#| comparison, right?

#| Consider this boxplot which shows the
#| relationship between the use of an air cleaner
#| and the number of symptom-free days of
#| asthmatic children. (The top and bottom lines
#| of the box indicate the 25% and 75% quartiles
#| of the data, and the horizontal line in the box
#| shows the 50%.) Since the box is above 0, the
#| number of symptom-free days for children with
#| asthma is bigger using the air cleaner. This is
#| good, right?

#| While it's somewhat informative, it's also
#| somewhat cryptic, since the y-axis is claiming
#| to show a change in number of symptom-free
#| days. Wouldn't it be better to show a
#| comparison?

#| Like this? Here's a graphic which shows two
#| boxplots, the one on the left showing the
#| results for a control group that doesn't use an
#| air cleaner alongside the previously shown
#| boxplot.

#| By showing the two boxplots side by side, you
#| can clearly see that using the air cleaner
#| increases the number of symptom-free days for
#| most asthmatic children. The plot on the right
#| (using the air cleaner) is generally higher
#| than the one on the left (the control group).

#| What does this graph NOT show you?

#1: Half the children in the control group had no improvement
#2: Using the air cleaner makes asthmatic children sicker
#3: Children in the control group had at most 3 symptom-free days
#4: 75% of the children using the air cleaner had at most 3 symptom-free days

#2 

#| So the first principle was to show a
#| comparison. The second principle is to show
#| causality or a mechanism of how your theory of
#| the data works. This explanation or systematic
#| structure shows your causal framework for
#| thinking about the question you're trying to
#| answer.

#| Consider this plot which shows the dual boxplot
#| we just showed, but next to it we have a
#| corresponding plot of changes in measures of
#| particulate matter.

#| This picture tries to explain how the air
#| cleaner increases the number of symptom-free
#| days for asthmatic children. What mechanism
#| does the graph imply?

#That the air cleaner reduces pollution

#| By showing the two sets of boxplots side by
#| side you're explaining your theory of why the
#| air cleaner increases the number of
#| symptom-free days. Onward!

#| So the first principle was to show some
#| comparison, the second was to show a mechanism,
#| so what will the third principle say to show?

# 1 COMPARISON, 2 MECHANISM 3 ... IS?
# MULTIVARIATE DATA!

#| What is multivariate data you might ask? In
#| technical (scientific) literature this term
#| means more than 2 variables. Two-variable plots
#| are what you saw in high school algebra.
#| Remember those x,y plots when you were learning
#| about slopes and intercepts and equations of
#| lines? They're valuable, but usually questions
#| are more complicated and require more
#| variables.

#| Sometimes, if you restrict yourself to two
#| variables you'll be misled and draw an
#| incorrect conclusion.

#| Consider this plot which shows the relationship
#| between air pollution (x-axis) and mortality
#| rates among the elderly (y-axis). The blue
#| regression line shows a surprising result.
#| (You'll learn about regression lines when you
#| take the fabulous Regression Models course.)

#| Fewer deaths with more pollution? That's a
#| surprise! Something's gotta be wrong, right? In
#| fact, this is an example of Simpson's paradox,
#| or the Yule–Simpson effect. Wikipedia
#| (http://en.wikipedia.org/wiki/Simpson%27s_paradox)
#| tells us that this "is a paradox in probability
#| and statistics, in which a trend that appears
#| in different groups of data disappears when
#| these groups are combined."

#| Suppose we divided this mortality/pollution
#| data into the four seasons. Would we see
#| different trends?

#| Yes, we do! Plotting the same data for the 4
#| seasons individually we see a different result

#NOTE ALL ARE POSITIVE REGRESSION LINES NOW NOT NEGATIVE 

# AS POLLUTION INCREASES MORE PPL DIE IN ALL SEASONS 

#| The fourth principle of analytic graphing
#| involves integrating evidence. This means not
#| limiting yourself to one form of expression.
#| You can use words, numbers, images as well as
#| diagrams. Graphics should make use of many
#| modes of data presentation. Remember, "Don't
#| let the tool drive the analysis!"

#| To show you what we mean, here's an example of
#| a figure taken from a paper published in the
#| Journal of the AMA. It shows the relationship
#| between pollution and hospitalization of people
#| with heart disease. As you can see, it's a lot
#| different from our previous plots. The solid
#| circles in the center portion indicate point
#| estimates of percentage changes in
#| hospitalization rates for different levels of
#| pollution. The lines through the circles
#| indicate confidence intervals associated with
#| these estimates. (You'll learn more about
#| confidence intervals in another great course,
#| this one on statistical inference.)

#| Note that on the right side of the figure is
#| another column of numbers, one for each of the
#| point estimates given. This column shows
#| posterior probabilities that relative risk is
#| greater than 0. This, in effect, is a measure
#| of the strength of the evidence showing the
#| correlation between pollution and
#| hospitalization.  The point here is that all of
#| this information is located in one picture so
#| that the reader can see the strength of not
#| only the correlations but the evidence as well.

#| The fifth principle of graphing involves
#| describing and documenting the evidence with
#| sources and appropriate labels and scales.
#| Credibility is important so the data graphics
#| should tell a complete story. Also, using R,
#| you want to preserve any code you use to
#| generate your data and graphics so that the
#| research can be replicated if necessary. This
#| allows for easy verification or finding bugs in
#| your analysis.

#| The sixth and final principle of analytic
#| graphing is maybe the most important. Content
#| is King! If you don't have something
#| interesting to report, your graphs won't save
#| you. Analytical presentations ultimately stand
#| or fall depending on the quality, relevance,
#| and integrity of their content.









































































